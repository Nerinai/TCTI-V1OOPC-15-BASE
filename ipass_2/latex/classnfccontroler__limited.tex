\hypertarget{classnfccontroler__limited}{}\section{nfccontroler\+\_\+limited Class Reference}
\label{classnfccontroler__limited}\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}


{\ttfamily \#include $<$nfccontroler\+\_\+limited.\+hpp$>$}

Inheritance diagram for nfccontroler\+\_\+limited\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classnfccontroler__limited}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classnfccontroler__limited_a97f279888626df09059338d149a3dcf1}{check\+Erro\+And\+Irq} (byte $\ast$result)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_a35a7cc1d586511b6a35294bc234530e0}{trancieve\+Data} (const byte $\ast$data\+\_\+in, const int data\+\_\+in\+\_\+lenght, byte $\ast$data\+\_\+out, int $\ast$data\+\_\+out\+\_\+lenght, bool crc=false, bool Bitwraping=false)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_ae1e689d34ba8bcd933c696b3f852dad6}{is\+Card} (byte $\ast$cardtype)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_a195f3de8d1529e00998f60ddf8058f6b}{select\+Card} (byte $\ast$Cardserial)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_a4eec4cf702e4c0062c33657e81a2069f}{authenticate\+Sector} (byte typekey, byte $\ast$block\+\_\+address, byte $\ast$key, byte $\ast$Cardserial)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_a5a8f607de57023a90962f6ac4fa2b5f1}{read\+Block} (byte block\+\_\+address, byte $\ast$data\+\_\+out)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_a70d6de379a501af2272da775c5d27c9e}{read\+Sector} (const int sectorsize, byte($\ast$sector\+\_\+out)\mbox{[}16\mbox{]}, byte typekey, byte $\ast$first\+\_\+block\+\_\+in\+\_\+sector, byte $\ast$key, byte $\ast$Cardserial)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_aeeeb82c8b45881239c7b2d9b4bce9ef5}{write\+Block} (const byte block\+\_\+address, const byte $\ast$data\+\_\+in, const int lenght)=0
\item 
virtual bool \hyperlink{classnfccontroler__limited_ad4d31d46ee21766eaaa0a4f1916cc8d8}{write\+Sector} (const int sectorsize, byte($\ast$sector\+\_\+in)\mbox{[}16\mbox{]}, byte typekey, byte $\ast$first\+\_\+block\+\_\+in\+\_\+sector, byte $\ast$key, byte $\ast$Cardserial)=0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
nfccontroler abstraction layer for functions on the card protocol side of the library.

This class contains the nfccontroler abstraction for the detection, selection, communication and error checking when communicating with an N\+FC card. 

\subsection{Member Function Documentation}
\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!authenticate\+Sector@{authenticate\+Sector}}
\index{authenticate\+Sector@{authenticate\+Sector}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{authenticate\+Sector(byte typekey, byte $\ast$block\+\_\+address, byte $\ast$key, byte $\ast$\+Cardserial)=0}{authenticateSector(byte typekey, byte *block_address, byte *key, byte *Cardserial)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::authenticate\+Sector (
\begin{DoxyParamCaption}
\item[{byte}]{typekey, }
\item[{byte $\ast$}]{block\+\_\+address, }
\item[{byte $\ast$}]{key, }
\item[{byte $\ast$}]{Cardserial}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a4eec4cf702e4c0062c33657e81a2069f}{}\label{classnfccontroler__limited_a4eec4cf702e4c0062c33657e81a2069f}
Function for authenticating access to a sector.

This function grants access to the specified sector of the card. The typekey parameter is used to specify which key is used for authentication. The block\+\_\+address parameter is used to select which sector is authenticated for. The key parameter is used to provide they key in byte array form to the specified sector. Any block in a sector may be targeted for authentication and will grant access to all blocks in that sector. This function returns true after successful authentication. 

Implemented in \hyperlink{class_r_c522_a84000801a44a02cf59601400b809f5a3}{R\+C522}, and \hyperlink{class_mifare___classic_a2e79d1842e44e1600f59fdfba4b22470}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!check\+Erro\+And\+Irq@{check\+Erro\+And\+Irq}}
\index{check\+Erro\+And\+Irq@{check\+Erro\+And\+Irq}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{check\+Erro\+And\+Irq(byte $\ast$result)=0}{checkErroAndIrq(byte *result)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void nfccontroler\+\_\+limited\+::check\+Erro\+And\+Irq (
\begin{DoxyParamCaption}
\item[{byte $\ast$}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a97f279888626df09059338d149a3dcf1}{}\label{classnfccontroler__limited_a97f279888626df09059338d149a3dcf1}
Function checking the error and I\+RQ results after sending or receiving data.

This function inserts the status of the registers in a byte array that is given to the function as a parameter.

The use function requires knowledge of how the chip returns these results. 

Implemented in \hyperlink{class_r_c522_a8797a7dcb6e4a7e3e30bf476ef47e894}{R\+C522}, and \hyperlink{class_mifare___classic_a9377d560c083320ad3b605df464a29e4}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!is\+Card@{is\+Card}}
\index{is\+Card@{is\+Card}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{is\+Card(byte $\ast$cardtype)=0}{isCard(byte *cardtype)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::is\+Card (
\begin{DoxyParamCaption}
\item[{byte $\ast$}]{cardtype}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_ae1e689d34ba8bcd933c696b3f852dad6}{}\label{classnfccontroler__limited_ae1e689d34ba8bcd933c696b3f852dad6}
Function for detecting if a card is in the EM field.

This function constantly polls for a card in the EM field When a card responds it inserts the response (Sak) in the cardtype byte array. This response can be used to identify the type of card. Before a card responds to this function it will not respond to any other command. It is currently not supported to have multiple cards in the EM field at the same time. Function will return true on successful detection of a card. 

Implemented in \hyperlink{class_r_c522_a6cef2c82c923eeed59bd3cb5e7a42090}{R\+C522}, and \hyperlink{class_mifare___classic_ae02721fc8b9268e93778fdc47d06d162}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!read\+Block@{read\+Block}}
\index{read\+Block@{read\+Block}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{read\+Block(byte block\+\_\+address, byte $\ast$data\+\_\+out)=0}{readBlock(byte block_address, byte *data_out)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::read\+Block (
\begin{DoxyParamCaption}
\item[{byte}]{block\+\_\+address, }
\item[{byte $\ast$}]{data\+\_\+out}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a5a8f607de57023a90962f6ac4fa2b5f1}{}\label{classnfccontroler__limited_a5a8f607de57023a90962f6ac4fa2b5f1}
Function for reading a block of data from the card.

This function reads data from a single block of data inside the card. After reading the data it inserts this in the data\+\_\+out array parameter. It is required to authenticate for the sector that the block resides in before attempting to read. Upon successful reading of data this function returns true. 

Implemented in \hyperlink{class_r_c522_a4a9843ee47bd24f6446bb8c327411076}{R\+C522}, and \hyperlink{class_mifare___classic_a6401f278760213b5c53e3c41aa5b0c98}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!read\+Sector@{read\+Sector}}
\index{read\+Sector@{read\+Sector}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{read\+Sector(const int sectorsize, byte($\ast$sector\+\_\+out)[16], byte typekey, byte $\ast$first\+\_\+block\+\_\+in\+\_\+sector, byte $\ast$key, byte $\ast$\+Cardserial)=0}{readSector(const int sectorsize, byte(*sector_out)[16], byte typekey, byte *first_block_in_sector, byte *key, byte *Cardserial)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::read\+Sector (
\begin{DoxyParamCaption}
\item[{const int}]{sectorsize, }
\item[{byte($\ast$)}]{sector\+\_\+out\mbox{[}16\mbox{]}, }
\item[{byte}]{typekey, }
\item[{byte $\ast$}]{first\+\_\+block\+\_\+in\+\_\+sector, }
\item[{byte $\ast$}]{key, }
\item[{byte $\ast$}]{Cardserial}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a70d6de379a501af2272da775c5d27c9e}{}\label{classnfccontroler__limited_a70d6de379a501af2272da775c5d27c9e}
Function for reading an entire sector of data from the card.

This function reads an entire sector of data. After reading the data it inserts this in the sector\+\_\+out 2d matrix parameter. Authentication is built in for this function. The typekey parameter is used to specify which key is used for authentication. The first\+\_\+block\+\_\+in\+\_\+sector parameter is used to select which sector is authenticated for. The key parameter is used to provide they key in byte array form to the specified sector. Upon successful reading of the sector this function returns true. 

Implemented in \hyperlink{class_r_c522_a6c6409ef5f4385e9d1efac5b2f9caed0}{R\+C522}, and \hyperlink{class_mifare___classic_a7caca9ec9a0cdc116f8056753ecc438c}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!select\+Card@{select\+Card}}
\index{select\+Card@{select\+Card}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{select\+Card(byte $\ast$\+Cardserial)=0}{selectCard(byte *Cardserial)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::select\+Card (
\begin{DoxyParamCaption}
\item[{byte $\ast$}]{Cardserial}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a195f3de8d1529e00998f60ddf8058f6b}{}\label{classnfccontroler__limited_a195f3de8d1529e00998f60ddf8058f6b}
Function for the selection of the card.

This function requests the U\+ID (Unique Identifier) from the card and then uses the U\+ID to select the card. It inserts the U\+ID into the Cardserial array. When a card has been successfully selected its U\+ID can be used to send other data and commands towards the card. This function returns true after the successful selection of a card. 

Implemented in \hyperlink{class_r_c522_a2b41c31a04a41b6098945b0fddcf1476}{R\+C522}, and \hyperlink{class_mifare___classic_aaa549c00df8619bb2f5a96bba093f005}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!trancieve\+Data@{trancieve\+Data}}
\index{trancieve\+Data@{trancieve\+Data}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{trancieve\+Data(const byte $\ast$data\+\_\+in, const int data\+\_\+in\+\_\+lenght, byte $\ast$data\+\_\+out, int $\ast$data\+\_\+out\+\_\+lenght, bool crc=false, bool Bitwraping=false)=0}{trancieveData(const byte *data_in, const int data_in_lenght, byte *data_out, int *data_out_lenght, bool crc=false, bool Bitwraping=false)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::trancieve\+Data (
\begin{DoxyParamCaption}
\item[{const byte $\ast$}]{data\+\_\+in, }
\item[{const int}]{data\+\_\+in\+\_\+lenght, }
\item[{byte $\ast$}]{data\+\_\+out, }
\item[{int $\ast$}]{data\+\_\+out\+\_\+lenght, }
\item[{bool}]{crc = {\ttfamily false}, }
\item[{bool}]{Bitwraping = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_a35a7cc1d586511b6a35294bc234530e0}{}\label{classnfccontroler__limited_a35a7cc1d586511b6a35294bc234530e0}
Function for using the simultaneous sending and receiving of data.

This function is used for sending data and commands to the card in the form of bytes. It sends the data stored in a byte array. After sending the data it inserts any received data in the data\+\_\+out array. It will also supply the amount of bytes received unless a nullptr is given to data\+\_\+out\+\_\+lenght. The crc and Bitwraping Booleans are used to trigger the additional functionality of Calculating and adding the crc and the use of a specialised bit frame for certain commands respectively. It is recommended to at least have a basic understanding of the card-\/protocol and microcontroller in use when using this function. 

Implemented in \hyperlink{class_r_c522_a8204221660aea7c393eb49340d29876a}{R\+C522}, and \hyperlink{class_mifare___classic_ac35863ec691f0a118156bea44c4cd7a7}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!write\+Block@{write\+Block}}
\index{write\+Block@{write\+Block}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{write\+Block(const byte block\+\_\+address, const byte $\ast$data\+\_\+in, const int lenght)=0}{writeBlock(const byte block_address, const byte *data_in, const int lenght)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::write\+Block (
\begin{DoxyParamCaption}
\item[{const byte}]{block\+\_\+address, }
\item[{const byte $\ast$}]{data\+\_\+in, }
\item[{const int}]{lenght}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_aeeeb82c8b45881239c7b2d9b4bce9ef5}{}\label{classnfccontroler__limited_aeeeb82c8b45881239c7b2d9b4bce9ef5}
Function for writing a block of data to the card.

This function writes data to a single block of data inside the card. The parameter data\+\_\+in is used to provide the data to write in byte array form. The data given to the function is appended with zeroes so a full block is always written. It is required to authenticate for the sector that the block resides in before attempting to write. Upon successful writing of data this function returns true. 

Implemented in \hyperlink{class_r_c522_a42c197d61571667a97176f7294b0a8dd}{R\+C522}, and \hyperlink{class_mifare___classic_adb793958d3f2601d336165e383a456f6}{Mifare\+\_\+\+Classic}.

\index{nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}!write\+Sector@{write\+Sector}}
\index{write\+Sector@{write\+Sector}!nfccontroler\+\_\+limited@{nfccontroler\+\_\+limited}}
\subsubsection[{\texorpdfstring{write\+Sector(const int sectorsize, byte($\ast$sector\+\_\+in)[16], byte typekey, byte $\ast$first\+\_\+block\+\_\+in\+\_\+sector, byte $\ast$key, byte $\ast$\+Cardserial)=0}{writeSector(const int sectorsize, byte(*sector_in)[16], byte typekey, byte *first_block_in_sector, byte *key, byte *Cardserial)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool nfccontroler\+\_\+limited\+::write\+Sector (
\begin{DoxyParamCaption}
\item[{const int}]{sectorsize, }
\item[{byte($\ast$)}]{sector\+\_\+in\mbox{[}16\mbox{]}, }
\item[{byte}]{typekey, }
\item[{byte $\ast$}]{first\+\_\+block\+\_\+in\+\_\+sector, }
\item[{byte $\ast$}]{key, }
\item[{byte $\ast$}]{Cardserial}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classnfccontroler__limited_ad4d31d46ee21766eaaa0a4f1916cc8d8}{}\label{classnfccontroler__limited_ad4d31d46ee21766eaaa0a4f1916cc8d8}
Function for writing an entire sector of data to the card.

This function writes an entire sector of data. The sector\+\_\+in parameter is used to provide the data to be written in 2d matrix form. Authentication is built in for this function. The typekey parameter is used to specify which key is used for authentication. The first\+\_\+block\+\_\+in\+\_\+sector parameter is used to select which sector is authenticated for. The key parameter is used to provide they key in byte array form to the specified sector. Upon successful writing of the sector this function returns true. 

Implemented in \hyperlink{class_r_c522_a11e060e686331017873edd877c3255cd}{R\+C522}, and \hyperlink{class_mifare___classic_a127803e07c148fe8d447a00e28be4a90}{Mifare\+\_\+\+Classic}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{nfccontroler__limited_8hpp}{nfccontroler\+\_\+limited.\+hpp}\end{DoxyCompactItemize}
